<section id="wager-period-overview" class="grid">
  <h2 class="full">
    Prices for Individual Metals from {{round(startDate)}} to {{round(endDate)}}
  </h2>
  
  {{#each series as metal}}
    <figure>
      <figcaption>
        {{formatName(metal.key)}}&nbsp;({{pctChange(metal.values)}})
      </figcaption>
      <WagerMetal name="{{metal.key}}" prices="{{metal.values}}"
        :x y="{{y(metal.values)}}" />
    </figure>
  {{/each}}
  
</section>

<script>
  import {extent} from "d3-array";
  import {nest} from "d3-collection";
  import {format} from "d3-format";
  import {scaleLinear} from "d3-scale";
  
  import WagerMetal from "./WagerMetal.html";
  
  const pct = format(".1%");
  
  const pctChange = (values) => {
    const first = values[0],
      last = values[values.length - 1];
      
    return pct((last.price - first.price) / first.price);
  };
  
  const formatName = (name) => (/[A-Za-z0-9 ]+/).exec(name)[0].trim();
  
  export default {
    components: {
      WagerMetal
    },
    
    computed: {
      pricesForPeriod: (prices, startDate, endDate) => {
        return prices.filter(d => d.year >= startDate && d.year <= endDate);
      },
      
      series: (pricesForPeriod) => (nest()
        .key(d => d.type)
        .sortValues((a, b) => a.year - b.year)
        .entries(pricesForPeriod)),
        
      x: (startDate, endDate) => ({
        scale: scaleLinear().domain([startDate, endDate]),
        value: d => d.year,
        format: String
      })
    },
    
    helpers: {
      y: function (values) {
        return {
          scale: scaleLinear().domain(extent(values, d => d.price)),
          value: d => d.price,
          format: format("$.0s")
        };
      },
      formatName,
      pctChange,
      round: Math.round
    }
  }
</script>